public class lesson_18_16 {
    //Наследование от абстрактного класса

    //Если вы наследовали свой класс от абстрактного класса,
    //нужно переопределить все унаследованные абстрактные методы — написать для них реализацию.
    //Иначе такой класс тоже придется объявить абстрактным.

    //Если в классе есть хотя бы один нереализованный метод, объявленный прямо в нем или унаследованный от класса-родителя,
    //класс считается абстрактным.

    //И зачем это все нужно? Зачем нужны абстрактные классы? Разве нельзя вместо них использовать обычные?
    //А вместо абстрактных методов просто писать две скобочки в качестве тела метода – {}?

    //Можно. Но эти ограничения сродни модификатору private.
    //Мы специально запрещали с помощью private прямой доступ к данным,
    //чтобы другие программисты и их классы пользовались только написанными нами public-методами.

    //То же и с абстрактным классом. Тот, кто написал этот класс, не хочет, чтобы создавались его объекты.
    //Наоборот, он рассчитывает на то, что от его абстрактного класса будут наследоваться и переопределяться абстрактные методы.

    //Преимущество этого подхода проявляется в больших проектах.
    //Чем больше классов, тем чётче приходится очерчивать их роли.
    //Вы увидите преимущество этого подхода, и уже в ближайшем будущем. Все через это проходят.

    //Класс Shapes обозначает геометрическую фигуру. В будущем от него можно будет унаследовать какую-то конкретную фигуру.
    //У этой фигуры можно будет посчитать периметр и площадь. У разных фигур они считаются по разным формулам.
    //И так как ни периметр, ни площадь невозможно высчитать у абстрактной фигуры, класс Shapes стоит сделать абстрактным.

    //Также сделай задел на будущее и создай в нем абстрактные методы getPerimeter() и getArea().
    //Методы будут возвращать значение типа double.
}

abstract class Shapes {
    abstract double getPerimeter();

    abstract double getArea();
}

