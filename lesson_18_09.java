public class lesson_18_09 {
    //Проверка типа объекта

    //Но тут нужно быть очень осторожным. Если вы сделаете так:
    //Животное зверь = new Кот();
    //Волк серыйВолк = (Волк) зверь;
    //Компилятор пропустит этот код, а вот во время выполнения программы возникнет ошибка! JVM кинет вам исключение:
    //Exception in thread "main" java.lang.ClassCastException: Кот cannot be cast to Волк

    //Ссылку на объект Кот можно сохранить только в переменные,
    //которые имеют тип класса-родителя для класса Кот: ДомашнееЖивотное, Животное и Object.

    //Все дело в том, что ссылка на объект используется для того, чтобы обращаться к методам и переменным этого объекта.
    //И если мы сохраним в переменную типа Животное ссылку на объект Кот, то никаких проблем с этим не возникнет:
    //у типа Кот всегда будет переменная и методы типа Животное: он же их унаследовал!

    //А вот если бы JVM разрешила сохранить ссылку на объект Кот в переменную типа Волк, могла бы возникнуть ситуация,
    //когда у переменной серыйВолк вызывается метод, который отсутствует у объекта Кот, на который эта переменная и ссылается.
    //Поэтому такое сохранение не разрешается.

    //В Java есть специальный оператор — instanceof, который позволяет проверить,
    //можно ли сохранить объект определенного типа в переменную определенного типа.
    //Выглядит он достаточно просто:
    //переменная instanceof Тип

    //Животное зверь = new Кот();
    //if (зверь instanceof Волк)
    //{
    //   Волк серыйВолк = (Волк) зверь;
    //}

    //Такой код не вызовет ошибок даже во время выполнения.

    //Вот еще несколько примеров с описанием ситуации:

    //Расширение типа	                                        Описание
    //Cow cow = new Whale();                                    Классическое расширение типа — оператор преобразования типа не требуется.
    //                                                          Теперь у объекта типа Whale можно вызывать только методы,
    //                                                          описанные в классе Cow.
    //                                                          Компилятор разрешит вызвать у переменной cow только те методы,
    //                                                          которые есть у ее типа — класса Cow.

    //Сужение типа
    //Cow cow = new Whale();                                    Классическое сужение типа: нужно добавить проверку типа и оператор
    //if (cow instanceof Whale)                                 приведения типа.Переменная cow типа
    //{                                                         Cow хранит ссылку на объект класса Whale. Мы проверяем, что это так и есть,
    //   Whale whale = (Whale) cow;                             и затем выполняем операцию преобразования (сужение) типа.
    //}                                                         Или как ее еще называют — type cast

    //Cow cow = new Cow();                                      //Ссылочное сужение типа можно провести и без проверки типа объекта.
    //Whale whale = (Whale) cow; // exception                   При этом, если в переменной cow хранился объект не класса Whale,
    //                                                          будет сгенерировано исключение — InvalidClassCastException.
}
